# Network layer

1. LAN или локальная сеть позволяет передавать данные между узлами в рамках сети одного типа, на коротких дистанциях. Работа производится на свитчах которые знают мак адреса устройства и контролируют передачу пакетов, разгружая сеть от шума и коллизий. Если сеть небольшая то свитчи справляются. Более того мак адреса имеют случайный набор значений и если ноды будут расположены оооочень далеко (или оочень много), то поиск нужного устройства будет долгим и непонятным. Эту проблему решает **сетевой уровень**, а точнее протокол IP и IP адресса.
2. IP представлен в точечно-десятичном формате. Маки определяют производители (поэтому по \*\* можно понять производителя), а IP определяют компании. Отсюда вывод - IP адреса относятся к сетям, а не устройствам в сетях.
3. Как на уровне ниже данные передаются биты, кадры. Так на этом уровне пейлоад теперь называется IP datagram
4. Датаграмма это такая структура, которая хранит всю необходимую информацию для сетей.

- 4 бита - версия (ip4v например)
- есть 4 бита для сервисов - они дают понимания роутерам какая диаграма приоритетней и важней.
- поле идентификации - понимает связь между пакетами если они являются одним единым блоком информации. В общем про этот блок нужно почитать еще Identification
- Датаграммы могут быть дефрагментированны. За эту инфу отвечают флаг смещения и поле фрагментации датаграммы.
- TTL флаг (время жизни) он уменьшается роутерами каждый раз когда попадает в один и тот же роутер, чтобы передача датаграммы не была бесконечной.
- Поле протокола. TCP или UPD
- Header checksum меняется каждый раз потому что меняется TTL. А смысл его такой же как у кадров. Получивший нод проверит что диаграмма дошла без изменений путем подсчета всех полей и сравнению хеша.
- IP адреса источника и назначения

Как я понял сети разные могут по разному понимать датаграммы и поэтому если понимают большие датаграммы, то отправленная датаграмма может в нее вместиться. Если нет - она дефрагментируется.

## IP адреса

IP адреса делятся на две части,

- первые **XXX**.XXX.XXX.XXX. это network ID,
- второе XXX.**XXX.XXX.XXX** это host id.
  Так же ip адреса делятся на три класса
- class a - первый октет используется для network Id, а последние для host id - **XXX**.XXX.XXX.XXX
- class b - первые два октета для network id, остальные для хоста - **XXX.XXX**.XXX.XXX
- class c - первые три октета для network id, последний для хоста - **XXX.XXX.XXX**.XXX

Adress resolution protocol - протокол который связывает MAC адреса с IP адресами. Т.е. это набор правил как найти нод с Маком по конкретному IP.
Как только датаграмма сформирована, она кладется в кадр как пейлоад. А значит устройство которое будет перенаправлять фрейм, должен знать MAC адрес назначения и он должен быть вложен в заголовок фрейма.
У всех устройств передающих фреймы, есть таблицы ARP которые содержат мак адреса и соответствующие IP.

Когда машина впервые выходит на связь, нигде естественно не упоминаются ее мак адреса и IP. И при первом взаимодействии, сетевая карта отправляет всем устройствам широковещательное ARP сообщение с ответом. Так заполняется таблица ARP благодря которой уже не надо делать эти широковещательные запросы опять. ARP таблицы не постоянны, у них есть срок очитски.

## SubNet

Если есть адрес 9.100.100.100 то Core Router получивший мессагу знает что это 9.0.0.0 и относится к классу A сети. Запрос с таким адресом направляется в роутер шлюз, который ответственнен за такой ip.  
Шлюзовый роутер служит для сообщений как путь входа/выхода для конкретной сети. (похож на core routers)
Попав в шлюзовый роутер, он смотрит на хост id. Как известно хостов id для класса A может быть 16 миллионов. Искать нужный очень долго. Да и в принципе стоько хостов не может быть подключенно к роутеру. Вот тут нужны сабнет. С помощью сабнета разбивают большую сеть. Каждая сабсеть будет иметь свой шлюз роутер.
Мы подошли к SubNet Id. В той сети у которой есть сабнет, то биты из хост id, принадлежат к subnet id.

Т.е. мессага идет с ip датаграммой, попадает в кор роутер, он направляет в шлюзовый роутер. Шлюзовый роутер либо знает по этому адресу машину либо направляет в другой роутер.
Subnet id можно вычислить по subnet маске.

- Например есть адрес 9.100.100.100 => 0000 1001 0110 0100 0110 0100 0110 0100
- есть маска 255.255.255.0 => 1111 1111 1111 1111 1111 1111 0000 0000
- _1111 1111_ 1111 1111 1111 1111 0000 0000 эту часть мы игнорим, это ид сети
- 1111 1111 _1111 1111 1111 1111_ 0000 0000 это говорит роутеру, что это сабнет ид.
- 1111 1111 1111 1111 1111 1111 _0000 0000_ это совственно хост в ip аддресе
- 0 адрес не исползуют
- 255 используют для броадкастинга
- 1-254 это то что используется для ip адресов.
  
  ## Роутеры
  Основная магия роутеров в том что они постоянно обновляют самый лучший маршрут для запроса. Все делается с помощью протоколов маршрутизатора.
  Их два.
  - interior gateway protocols (нужны для того чтобы шарить инфу между одной автономной системой (а единственная автономная система это коллекция сетей под контролем одного интернет оператора. Например какая то корпорация с кучами локальных сетей. Или куча роутеров под одним интернет провайдером. ) ):
      * Link state protocols - Это более детальная инфа о роутере с более сложным алгоритмом для вычисления самого быстрого маршрута между далеко удаленными роутерами. С учетом того что железо дешевеет и улучшается, данный протокол уже не проблема и является современным протоколом.
      * distance-vector protocols - это старый протокол. Таблица маршрутов где ведется подсчет прыжков запроса. Этот лист подсчетов шлется всем соседям роутера (все кто подключены напрямую к данному роутеру). Данный лист называется Vector. Т.е. роутер с этими протоколами незнает детайей маршрута, только знает о роутерах соедененных непосредственно. Обновление инфы между непосредственными роутерами происходит быстро и хорошо. А с удаленными роутерами будет дольше. Для этого есть Link state protocols.
        * Пример: Один роутер A знает что до пункта назначения X в таблице записанно 10 прыжков. Рядом с ним соединен напрямую другой роутер B . Другой роутер B знает более быстрый путь до X, 5 прыжков. Роутер B делится своим вектором с A, а A обновляет свою таблицу более быстрым маршрутом. 

  - exterioi gateway protocols (шарят инфу между независимыми автономными системами)
