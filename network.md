# Network layer

1. LAN или локальная сеть позволяет передавать данные между узлами в рамках сети одного типа, на коротких дистанциях. Работа производится на свитчах которые знают мак адреса устройства и контролируют передачу пакетов, разгружая сеть от шума и коллизий. Если сеть небольшая то свитчи справляются. Более того мак адреса имеют случайный набор значений и если ноды будут расположены оооочень далеко (или оочень много), то поиск нужного устройства будет долгим и непонятным. Эту проблему решает **сетевой уровень**, а точнее протокол IP и IP адресса.
2. IP представлен в точечно-десятичном формате. Маки определяют производители (поэтому по \*\* можно понять производителя), а IP определяют компании. Отсюда вывод - IP адреса относятся к сетям, а не устройствам в сетях.
3. Как на уровне ниже данные передаются биты, кадры. Так на этом уровне пейлоад теперь называется IP datagram
4. Датаграмма это такая структура, которая хранит всю необходимую информацию для сетей.

- 4 бита - версия (ip4v например)
- есть 4 бита для сервисов - они дают понимания роутерам какая диаграма приоритетней и важней.
- поле идентификации - понимает связь между пакетами если они являются одним единым блоком информации. В общем про этот блок нужно почитать еще Identification
- Датаграммы могут быть дефрагментированны. За эту инфу отвечают флаг смещения и поле фрагментации датаграммы.
- TTL флаг (время жизни) он уменьшается роутерами каждый раз когда попадает в один и тот же роутер, чтобы передача датаграммы не была бесконечной.
- Поле протокола. TCP или UPD
- Header checksum меняется каждый раз потому что меняется TTL. А смысл его такой же как у кадров. Получивший нод проверит что диаграмма дошла без изменений путем подсчета всех полей и сравнению хеша.
- IP адреса источника и назначения

Как я понял сети разные могут по разному понимать датаграммы и поэтому если понимают большие датаграммы, то отправленная датаграмма может в нее вместиться. Если нет - она дефрагментируется.

## IP адреса

IP адреса делятся на две части,

- первые **XXX**.XXX.XXX.XXX. это network ID,
- второе XXX.**XXX.XXX.XXX** это host id.
  Так же ip адреса делятся на три класса
- class a - первый октет используется для network Id, а последние для host id - **XXX**.XXX.XXX.XXX
- class b - первые два октета для network id, остальные для хоста - **XXX.XXX**.XXX.XXX
- class c - первые три октета для network id, последний для хоста - **XXX.XXX.XXX**.XXX

Adress resolution protocol - протокол который связывает MAC адреса с IP адресами. Т.е. это набор правил как найти нод с Маком по конкретному IP.
Как только датаграмма сформирована, она кладется в кадр как пейлоад. А значит устройство которое будет перенаправлять фрейм, должен знать MAC адрес назначения и он должен быть вложен в заголовок фрейма.
У всех устройств передающих фреймы, есть таблицы ARP которые содержат мак адреса и соответствующие IP.

Когда машина впервые выходит на связь, нигде естественно не упоминаются ее мак адреса и IP. И при первом взаимодействии, сетевая карта отправляет всем устройствам широковещательное ARP сообщение с ответом. Так заполняется таблица ARP благодря которой уже не надо делать эти широковещательные запросы опять. ARP таблицы не постоянны, у них есть срок очитски.

## SubNet

Если есть адрес 9.100.100.100 то Core Router получивший мессагу знает что это 9.0.0.0 и относится к классу A сети. Запрос с таким адресом направляется в роутер шлюз, который ответственнен за такой ip.  
Шлюзовый роутер служит для сообщений как путь входа/выхода для конкретной сети. (похож на core routers)
Попав в шлюзовый роутер, он смотрит на хост id. Как известно хостов id для класса A может быть 16 миллионов. Искать нужный очень долго. Да и в принципе стоько хостов не может быть подключенно к роутеру. Вот тут нужны сабнет. С помощью сабнета разбивают большую сеть. Каждая сабсеть будет иметь свой шлюз роутер.
Мы подошли к SubNet Id. В той сети у которой есть сабнет, то биты из хост id, принадлежат к subnet id.

Т.е. мессага идет с ip датаграммой, попадает в кор роутер, он направляет в шлюзовый роутер. Шлюзовый роутер либо знает по этому адресу машину либо направляет в другой роутер.
Subnet id можно вычислить по subnet маске.

- Например есть адрес 9.100.100.100 => 0000 1001 0110 0100 0110 0100 0110 0100
- есть маска 255.255.255.0 => 1111 1111 1111 1111 1111 1111 0000 0000
- _1111 1111_ 1111 1111 1111 1111 0000 0000 эту часть мы игнорим, это ид сети
- 1111 1111 _1111 1111 1111 1111_ 0000 0000 это говорит роутеру, что это сабнет ид.
- 1111 1111 1111 1111 1111 1111 _0000 0000_ это совственно хост в ip аддресе
- 0 адрес не исползуют
- 255 используют для броадкастинга
- 1-254 это то что используется для ip адресов.

  ## Роутеры

  Основная магия роутеров в том что они постоянно обновляют самый лучший маршрут для запроса. Все делается с помощью протоколов маршрутизатора.
  Их два.

  - interior gateway protocols (нужны для того чтобы шарить инфу между одной автономной системой (а единственная автономная система это коллекция сетей под контролем одного интернет оператора. Например какая то корпорация с кучами локальных сетей. Или куча роутеров под одним интернет провайдером. ) ):

    - Link state protocols - Это более детальная инфа о роутере с более сложным алгоритмом для вычисления самого быстрого маршрута между далеко удаленными роутерами. С учетом того что железо дешевеет и улучшается, данный протокол уже не проблема и является современным протоколом.
    - distance-vector protocols - это старый протокол. Таблица маршрутов где ведется подсчет прыжков запроса. Этот лист подсчетов шлется всем соседям роутера (все кто подключены напрямую к данному роутеру). Данный лист называется Vector. Т.е. роутер с этими протоколами незнает детайей маршрута, только знает о роутерах соедененных непосредственно. Обновление инфы между непосредственными роутерами происходит быстро и хорошо. А с удаленными роутерами будет дольше. Для этого есть Link state protocols.
      - Пример: Один роутер A знает что до пункта назначения X в таблице записанно 10 прыжков. Рядом с ним соединен напрямую другой роутер B . Другой роутер B знает более быстрый путь до X, 5 прыжков. Роутер B делится своим вектором с A, а A обновляет свою таблицу более быстрым маршрутом.

  - exterioi gateway protocols (шарят инфу между независимыми автономными системами). Шарят между роутерами границами автономных систем (Т.е. напрмер между разными корпорациями)

Есть 3 типа ip адрессов которые не контролируются кор и эйдж роутерами:

- 10.0.0.0/8 ;
- 172.16.0.0/12
- 192.168.0.0/16

# Transport layer

- Позволяет отправить данные в нужную сеть приложений.
- Multipluxing traffic - приложения могут отправлять траффик множеству разных получателям.
- Demultipluxing traffic - это наоборот, сбор всего трафика и формирование данных для конретного получателя.
- Transport Layer пользуется мульти и демультиплаксингом трафика с помощью портов.
- Порт 16 битный номер указывает на конкретную принимающую службу. (например http прослушивалка на порту 80, трафик направят на этот порт конкретного ip адреса.)
- Ip адрес с портом (192.168.45.2:80) называется socket address/ socket number.
- FTP (file transfer protocol) слушается для передачи файлов на порте 21
- IP датаграмма хранит в себе TCP сегмент (пейлоад уровня транспорта)
- TCP сегмент состоит из заголовка и пейлоада.

## TCP сегмент

- порт источника (эфимерные порты) и получателя
- последовательность номеров - показывает позицию текущего сегмента из всех передаваемых сегментов. Потому что на низких уровнях кадры не могут передвавть одним разом всю инфу что мы хотим передать. Поэтому транспортный слой делит их на сегменты.
- номер acknowledgment - указывает на следующий сегмент который ожидается.
- длина заголовка - так принимающее устройство понимает где пейлоад.
- контролирующие флаги.

### urgent control flag

- флаг который говорит что это срочный сегмент. А значит сегмент содержит некоторую полезную инфу.

### acknowledge control flag

- значит что aknowledge номер нужно/нет обследовать

### PSH (push) control flag

- говорит о том что передающее устройство хочет чтобы получаемый девайс отдал текущие данные асап. Т.е. устройство может буферовать получаемые сегменты и слать сперва только самые важные дальше.

### RST (reset) control flag

- Когда один из звеньев получающих сегменты, не может их собрать воедино и не понимает что происходит и просит начать все сначала.

### SYN (sunchronize) control flag

- Когда устанавливается соединение, то понимаем по этому флагу что получатель знает как смотреть на sequence number поле из сегмента.

### Fin (finish) control flag

- Этот флаг говорит что больше нечего отправлять.

## как устанавливаются тсп соединения начало (три рукопожатия)

- Комп А хочет связаться с компом B
- => Сперва шлет сегмент с флагом SYN
- <= Получает сегмент с флагами SYN\ACK типа понимает какой номер последовательности и где читать
- => отправляет ACK типа, ок, я понял что ты знаешь.
  Этот блок запросов работает всякий раз при установки соединений. Называется тройное рукопожатие. Рукопожатие -

  ## как устанавливаются тсп соединения Конец (четыре рукопожатия)

  - Комп B шлет сегмент с флагом FIN
  - => прилетает сегмент с флагом ACK
  - => А потом шлет FIN
  - <= Говорит ACK

## Socket

- Сокет - это запуск конечной точки. TCP сокеты соответсвенно нуждаются в программах. Т.е. мы отправляем на порт трафик и если программа инстанцирует сокет, тогда она сможет дать ответ.
- Сокет имеет несколько состояний:
  - Listen - слушает приходящие соединения. Статус на сервере.
  - SYN_Sent - отправили запрос на синхронизацию нл соединения пока нет. Статус на клиенте.
  - SYN-RECIEVED - сокет теперь слушает и отправил сегмент syn/ack
  - ESTABLISHED - соединения слушают друг друга
  - FIN_WAIT - ждем ACK о финализации
  - CLOSE_WAIT - Связь отключили, но сокет не освобожден еще
  - CLOSED - связь закончена

## Connectionless protocol UDP (user datagram protocol)

- TCP делает кучу телодвижений, кучу трафика чтобы убедиться что все данные достигнут точки назначения.
- UDP по барабану все эти операции с проверкой доставки. Просто отправляем пакет по порту. По этому протоколу можно слать видео.

## Firewalls

- Файрволы это устройства (или ПО) блокирующие трафик по определенным критериям.
- Файрволы бывают разных уровней. TCP, IP, APP.

# Application Layer

- Позволяет приложениям общаться способом который они понимают.
- Приложение кладет свой пейлоад в сегмент TCP. Пейлоад может быть любой, главное чтобы он соответствовал протоколу получателя.
- Популярные веб сервера MS IIS, apache, nginx
- Для web трафика, протокол приложений является http

# DNS

- днс это сервис уровня приложения
- domain name system это глобальная и распределенная система распознования имен в ip адреса.
- domain name - термин который резолвится dns
- ip трудно запоминать и к тому же он может поменяться по разным причинам. Доменное имя останется неизменным.
- Чем дальше ноды расположенны между друг другом тем дольше инфа идет. Поэтому стараются распределить датацентры ближе к точкам потребления. И когда резолвится доменное имя, то определяется ip близжайшей ноды.
- Сервер днс это последнее звено которое нужно для работы сети в интернете.
- Типы серверов днс:

* Кеширующий имена сервер -
* Рекурсивные имена сервер - Этот и выше нужен для хранения таблиц имен. Рекурсивный сервер делает полную днс резолюцию запроса.
* Корневые имена сервер
* TLD имена сервер
* Авторитативные имена сервер

## пример

- Я набираю адрес в браузере. Я ввел только доменное имя. Чтобы установилось тсп соединение, нужен ip адресс.
- Так как я нахожусь в некоторой сети, то должен быть днс сервер.
- днс начинает резолвить имя. Он шлет запросы 13 рутовым днс серверам.
- рутовые днс сервера шлют адреса TLD (TOP LEVEL DOMAIN) серверов. (это .com, .org, .ru и т.д.)
- теперь днс сервер опрашивает tld сервера и получает адрес авторизации имен днс сервера пункта назначения
- днс сервер авторизации возвращает ip для днс сервера
- днс сервер резолвит рекурсивно имя и кеширует имя с ip у себя. А ip возвращается запрашивающему.
- TTL (time to live ) Владельцы доменных имен конфигурируют свое имя сколько оно живет в секундах на серверах днс.
- На примере резолвинга имени днс видно почему до сих пор существует протокол UPD, потому что он не требует учета проверок соединения и количество пакетов передаваемых между участниками общения драматически мал.
